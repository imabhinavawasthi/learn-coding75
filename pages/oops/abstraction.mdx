## Abstraction

**Abstraction** is the process of **simplifying real-world problems** by focusing on **essential aspects** and **hiding unnecessary details**.

By modeling the **relevant data and operations**, abstraction allows us to create a **standardized solution template** that can be reused for similar problems.  
This improves **modularity, maintainability, and scalability** of software systems.

---

### Types of Abstraction in OOP:

#### 1. Data Abstraction

Data abstraction involves abstracting or encapsulating data entities, focusing on their essential characteristics while hiding unnecessary
details.

It allows for the representation of real-world entities in a simplified an manageable form within the program.

Examples of data abstraction include classes, objects, and abstract data types (ADTs), which define data structures and their associated
behaviors without revealing their internal implementation details

- Focuses on representing **real-world entities** by highlighting only the **essential data**.
- **Hides implementation details** of the data structure.
- Helps to manage complex data through simplified models.

**Examples:**
- Classes
- Objects
- Abstract Data Types (ADTs)

#### 2. Process Abstraction

Process abstraction, on the other hand, hides the underlying implementation details of a process or algorithm, focusing on its
high-level functionality or behavior.

It enables the separation of concerns by abstracting away the internal workings of a process, allowing users to interact with it at a higher
level of abstraction.

Examples of process abstraction include interfaces, which define a contract for implementing classes without specifying the
implementation details, and function prototypes or method signatures, which declare the input/output parameters and return type of a
function/method without providing its implementation.

- Focuses on **hiding the implementation** of **algorithms or processes**.
- Users interact with **interfaces or method signatures**, not the internal logic.

**Examples:**
- Interfaces (e.g., in Java)
- Function Prototypes or Method Signatures

---

### Why Abstraction Matters:

- Encourages **code reusability**
- Promotes **clean architecture**
- Enhances **encapsulation** by exposing only what's necessary
- Makes software systems easier to **maintain** and **scale**

---

### Abstraction Reference (With Code Examples):

- [C++ Abstraction](https://www.scaler.com/topics/cpp/abstraction-in-cpp/)
- [Java Abstraction (Abstract classes & Interfaces)](https://www.upgrad.com/blog/abstraction-in-java/)
- [Python Abstraction](https://www.scaler.com/topics/python/data-abstraction-in-python/)
